/*
문제 ) n * 3 장판을 정해진 타일로 타일링 해라.
새로생기는 특수 패턴 
( ex_ n=2에서 n=1의 모형을 이어붙이지 않은 새로운 패턴)
( ex2_ n=3에서 n=1과n=2를 이어붙어 만들어진 패턴이 아닌 새로운 패턴)
 n = 1  -> 1 
 n = 2  -> 2
 n = 3  -> 5
 n = 4  -> 2
 n = 5  -> 2
 n = 6  -> 4
 n = 4  부터는  2 2 4 반복된다. ( n= 4,7,10, ... -> 2 )

dp[2]= 3
dp[3]= 10
dp[4]= 23 -> 10*1 + 3*2 + 1*5 + 1*2 
dp[5]= 62 -> ...
dp[6]= 170 -> ...

점화식  n6 = (n5 * 1) + (n4 * 2) + (n3 * 5) //+ (n2 * 2) + (n1 * 2) + (n0 * 4)
점화식  n7 = (n6 * 1) + (n5 * 2) + (n4 * 5) //+ (n3 * 2) + (n2 * 2) + (n1 * 4) + (n0 * 2)
점화식  n8 = (n7 * 1) + (n6 * 2) + (n5 * 5) //+ (n4 * 2) + (n3 * 2) + (n2 * 4) + (n1 * 2) + (n0 * 2)

-> dp[6]= 62*1 + 23*2 + 10*5        //                             + 3*2 + 1*2 + 1*4  (12)(=tailDp)
-> dp[7] =170*1 + 62*2 + 23*5       //                      + 10*2 + 3*2 + 1*4 + 1*2  (32)
-> dp[8] = 441*1 + 170*2 + 62*5     //               + 23*2 + 10*2 + 3*4 + 1*2 + 1*2  (82)
-> dp[9] = 1173*1 + 441*2 + 170*5   //        + 62*2 + 23*2 + 10*4 + 3*2 + 1*2 + 1*4 (222)
-> dp[10] = 3127*1 + 1173*2 + 441*5 //+ 170*2 + 62*2 + 23*4 + 10*2 + 3*2 + 1*4 + 1*2 (588)
// 뒷부분은 반복되는걸 최적화 하기 위해 표시함.
최적화 방법
 2 2 4 반복함 
 ->dp[9]에서 dp[6]과 같은 부분, 그 다음 뒷부분 (새로운)3자리 탄생
 ->dp[10]에서 dp[7]과 같은 부분, 그 다음 뒷부분 (새로운)3자리 탄생
규칙생성됨 .

*/
#include <string>
#include <vector>

using namespace std;

const int MOD = 1'000'000'007;

int d[3] = {2, 2, 4};
long long dp[100'001];     //0~100'000
long long tailDp[100'001]; //6~100'000

int solution(int n)
{
    int answer = 0;

    dp[0] = 1;
    dp[1] = 1;
    dp[2] = 3;
    dp[3] = 10;
    dp[4] = 23;
    dp[5] = 62;
    dp[6] = 170;
    dp[7] = 441;
    dp[8] = 1173;

    tailDp[6] = 12;
    tailDp[7] = 32;
    tailDp[8] = 82;

    for(int i =9 ; i<=n ;i++){
        tailDp[i] = 2 * dp[i - 4] + 2 * dp[i - 5] + 4 * dp[i - 6] + tailDp[i - 3];
        dp[i] = (dp[i - 1] + 2 * dp[i - 2] + 5 * dp[i - 3] + tailDp[i]) % MOD;
    }

    answer = dp[n];

    return answer;
}